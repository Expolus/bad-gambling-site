<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Shape Roller with Gradient Rolling</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
      background-color: #f0f0f0;
    }
    h1 {
      margin-bottom: 1rem;
    }
    button {
      padding: 10px 20px;
      font-size: 1rem;
      margin-bottom: 1.5rem;
      cursor: pointer;
      background-color: #28a745;
      color: white;
      border: none;
      border-radius: 8px;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #218838;
    }
    #canvas {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      margin-bottom: 2rem;
    }
    #collection {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 1rem;
      width: 100%;
      max-width: 800px;
    }
    .collection-item {
      background: white;
      padding: 0.5rem;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .collection-item canvas {
      border-radius: 8px;
    }
    @media (max-width: 600px) {
    #canvas {
        width: 200px;
        height: 200px;
    }
    button {
        font-size: 1.2rem;
        padding: 12px 24px;
    }
    h1 {
        font-size: 1.8rem;
    }
    }
  </style>
</head>
<body>

<h1>Shape Roller</h1>
<button id="roll">Roll!</button>
<canvas id="canvas" width="300" height="300"></canvas>

<h2>Your Collection</h2>
<div id="collection"></div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const collectionDiv = document.getElementById('collection');

const shapes = ['circle', 'square', 'triangle', 'star', 'hexagon', 'heart', 'pentagon'];

let rolling = false;
let animationFrame;
let animationInterval;
let fakeGradients = [];
let currentFakeIndex = 0;

// Utility functions
function randomColor() {
  const r = Math.floor(Math.random() * 256);
  const g = Math.floor(Math.random() * 256);
  const b = Math.floor(Math.random() * 256);
  return `rgb(${r}, ${g}, ${b})`;
}

function drawShape(ctx, shape, colorTop, colorBottom, width, height) {
  ctx.clearRect(0, 0, width, height);
  const gradient = ctx.createLinearGradient(0, 0, 0, height);
  gradient.addColorStop(0, colorTop);
  gradient.addColorStop(1, colorBottom);
  ctx.fillStyle = gradient;

  ctx.beginPath();
  const cx = width / 2;
  const cy = height / 2;
  const size = Math.min(width, height) / 2.5;

  switch(shape) {
    case 'circle':
      ctx.arc(cx, cy, size, 0, Math.PI * 2);
      break;
    case 'square':
      ctx.rect(cx - size/2, cy - size/2, size, size);
      break;
    case 'triangle':
      ctx.moveTo(cx, cy - size);
      ctx.lineTo(cx - size, cy + size);
      ctx.lineTo(cx + size, cy + size);
      ctx.closePath();
      break;
    case 'star':
      drawStar(ctx, cx, cy, 5, size, size/2);
      break;
    case 'hexagon':
      drawPolygon(ctx, cx, cy, 6, size);
      break;
    case 'pentagon':
      drawPolygon(ctx, cx, cy, 5, size);
      break;
    case 'heart':
      drawHeart(ctx, cx, cy, size);
      break;
  }
  ctx.fill();
}

function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
  let rot = Math.PI / 2 * 3;
  let x = cx;
  let y = cy;
  const step = Math.PI / spikes;

  ctx.moveTo(cx, cy - outerRadius);
  for (let i = 0; i < spikes; i++) {
    x = cx + Math.cos(rot) * outerRadius;
    y = cy + Math.sin(rot) * outerRadius;
    ctx.lineTo(x, y);
    rot += step;

    x = cx + Math.cos(rot) * innerRadius;
    y = cy + Math.sin(rot) * innerRadius;
    ctx.lineTo(x, y);
    rot += step;
  }
  ctx.lineTo(cx, cy - outerRadius);
  ctx.closePath();
}

function drawPolygon(ctx, cx, cy, sides, radius) {
  const angle = (2 * Math.PI) / sides;
  ctx.moveTo(cx + radius * Math.cos(0), cy + radius * Math.sin(0));

  for (let i = 1; i <= sides; i++) {
    ctx.lineTo(
      cx + radius * Math.cos(i * angle),
      cy + radius * Math.sin(i * angle)
    );
  }
}

function drawHeart(ctx, cx, cy, size) {
  ctx.moveTo(cx, cy + size/4);
  ctx.bezierCurveTo(cx + size, cy - size/2, cx + size/2, cy - size, cx, cy - size/4);
  ctx.bezierCurveTo(cx - size/2, cy - size, cx - size, cy - size/2, cx, cy + size/4);
}

function roll() {
  if (rolling) return; // Prevent double roll
  rolling = true;

  const shape = shapes[Math.floor(Math.random() * shapes.length)];

  // Generate 4 random fake gradients
  fakeGradients = [];
  for (let i = 0; i < 4; i++) {
    fakeGradients.push([randomColor(), randomColor()]);
  }
  
  currentFakeIndex = 0;

  // Animate switching gradients every 150ms
  animationInterval = setInterval(() => {
    const [colorTop, colorBottom] = fakeGradients[currentFakeIndex];
    drawShape(ctx, shape, colorTop, colorBottom, canvas.width, canvas.height);
    currentFakeIndex = (currentFakeIndex + 1) % fakeGradients.length;
  }, 150);

  // After 2 seconds, stop and pick real colors
  setTimeout(() => {
    clearInterval(animationInterval);
    const colorTop = randomColor();
    const colorBottom = randomColor();
    drawShape(ctx, shape, colorTop, colorBottom, canvas.width, canvas.height);

    const collection = JSON.parse(localStorage.getItem('collection') || '[]');
    collection.push({ shape, colorTop, colorBottom });
    localStorage.setItem('collection', JSON.stringify(collection));
    addToCollection({ shape, colorTop, colorBottom });

    rolling = false;
  }, 2000); // 2 seconds
}

function addToCollection(data) {
  const item = document.createElement('div');
  item.className = 'collection-item';

  const miniCanvas = document.createElement('canvas');
  miniCanvas.width = 100;
  miniCanvas.height = 100;
  const miniCtx = miniCanvas.getContext('2d');

  drawShape(miniCtx, data.shape, data.colorTop, data.colorBottom, miniCanvas.width, miniCanvas.height);

  item.appendChild(miniCanvas);
  collectionDiv.appendChild(item);
}

function loadCollection() {
  const collection = JSON.parse(localStorage.getItem('collection') || '[]');
  collection.forEach(addToCollection);
}

// Button event
document.getElementById('roll').addEventListener('click', roll);

// Load existing collection
window.addEventListener('load', () => {
  loadCollection();
});
</script>

</body>
</html>
